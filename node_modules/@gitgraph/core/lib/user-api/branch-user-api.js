"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const commit_1 = require("../commit");
const utils_1 = require("../utils");
class BranchUserApi {
    // tslint:enable:variable-name
    constructor(branch, graph, onGraphUpdate) {
        this._branch = branch;
        this.name = branch.name;
        this._graph = graph;
        this._onGraphUpdate = onGraphUpdate;
    }
    branch(args) {
        const options = typeof args === "string" ? { name: args } : args;
        options.from = this;
        return this._graph.createBranch(options).getUserApi();
    }
    commit(options) {
        // Deal with shorter syntax
        if (typeof options === "string")
            options = { subject: options };
        if (!options)
            options = {};
        this._commitWithParents(options, []);
        this._onGraphUpdate();
        return this;
    }
    merge(...args) {
        let options = args[0];
        if (!isBranchMergeOptions(options)) {
            options = {
                branch: args[0],
                fastForward: false,
                commitOptions: { subject: args[1] },
            };
        }
        const { branch, fastForward, commitOptions, } = options;
        const branchName = typeof branch === "string" ? branch : branch.name;
        const branchLastCommitHash = this._graph.refs.getCommit(branchName);
        if (!branchLastCommitHash) {
            throw new Error(`The branch called "${branchName}" is unknown`);
        }
        let canFastForward = false;
        if (fastForward) {
            const lastCommitHash = this._graph.refs.getCommit(this._branch.name);
            if (lastCommitHash) {
                canFastForward = this._areCommitsConnected(lastCommitHash, branchLastCommitHash);
            }
        }
        if (fastForward && canFastForward) {
            this._fastForwardTo(branchLastCommitHash);
        }
        else {
            this._commitWithParents(Object.assign({}, commitOptions, { subject: (commitOptions && commitOptions.subject) ||
                    `Merge branch ${branchName}` }), [branchLastCommitHash]);
        }
        this._onGraphUpdate();
        return this;
    }
    tag(options) {
        if (typeof options === "string") {
            this._graph.getUserApi().tag({ name: options, ref: this._branch.name });
        }
        else {
            this._graph.getUserApi().tag(Object.assign({}, options, { ref: this._branch.name }));
        }
        return this;
    }
    /**
     * Checkout onto this branch.
     */
    checkout() {
        this._graph.currentBranch = this._branch;
        return this;
    }
    // tslint:disable:variable-name - Prefix `_` = explicitly private for JS users
    _commitWithParents(options, parents) {
        const parentOnSameBranch = this._graph.refs.getCommit(this._branch.name);
        if (parentOnSameBranch) {
            parents.unshift(parentOnSameBranch);
        }
        else if (this._branch.parentCommitHash) {
            parents.unshift(this._branch.parentCommitHash);
        }
        const { tag } = options, commitOptions = __rest(options, ["tag"]);
        const commit = new commit_1.Commit(Object.assign({ hash: this._graph.generateCommitHash(), author: this._branch.commitDefaultOptions.author || this._graph.author, subject: this._branch.commitDefaultOptions.subject ||
                this._graph.commitMessage }, commitOptions, { parents, style: this._getCommitStyle(options.style) }));
        if (parentOnSameBranch) {
            // Take all the refs from the parent
            const parentRefs = this._graph.refs.getNames(parentOnSameBranch);
            parentRefs.forEach((ref) => this._graph.refs.set(ref, commit.hash));
        }
        else {
            // Set the branch ref
            this._graph.refs.set(this._branch.name, commit.hash);
        }
        // Add the new commit
        this._graph.commits.push(commit);
        // Move HEAD on the last commit
        this.checkout();
        this._graph.refs.set("HEAD", commit.hash);
        // Add a tag to the commit if `option.tag` is provide
        if (tag)
            this.tag(tag);
    }
    _areCommitsConnected(parentCommitHash, childCommitHash) {
        const childCommit = this._graph.commits.find(({ hash }) => childCommitHash === hash);
        if (!childCommit)
            return false;
        const isFirstCommitOfGraph = childCommit.parents.length === 0;
        if (isFirstCommitOfGraph)
            return false;
        if (childCommit.parents.includes(parentCommitHash)) {
            return true;
        }
        // `childCommitHash` is not a direct child of `parentCommitHash`.
        // But maybe one of `childCommitHash` parent is.
        return childCommit.parents.some((directParentHash) => this._areCommitsConnected(parentCommitHash, directParentHash));
    }
    _fastForwardTo(commitHash) {
        this._graph.refs.set(this._branch.name, commitHash);
    }
    _getCommitStyle(style = {}) {
        return Object.assign({}, utils_1.withoutUndefinedKeys(this._graph.template.commit), utils_1.withoutUndefinedKeys(this._branch.commitDefaultOptions.style), style, { message: Object.assign({}, utils_1.withoutUndefinedKeys(this._graph.template.commit.message), utils_1.withoutUndefinedKeys(this._branch.commitDefaultOptions.style.message), style.message, utils_1.withoutUndefinedKeys({
                display: this._graph.shouldDisplayCommitMessage && undefined,
            })), dot: Object.assign({}, utils_1.withoutUndefinedKeys(this._graph.template.commit.dot), utils_1.withoutUndefinedKeys(this._branch.commitDefaultOptions.style.dot), style.dot) });
    }
}
exports.BranchUserApi = BranchUserApi;
function isBranchMergeOptions(options) {
    return typeof options === "object" && !(options instanceof BranchUserApi);
}
//# sourceMappingURL=branch-user-api.js.map